import { TJSGameSettings } from '@typhonjs-fvtt/runtime/svelte/store/fvtt/settings';
import { writable } from 'svelte/store';
import { TJSDialog } from '@typhonjs-fvtt/runtime/svelte/application';
import { TJSSvelte } from '@typhonjs-fvtt/runtime/svelte/util';
import { localize } from '@typhonjs-fvtt/runtime/util/i18n';
import { isObject, isIterable } from '@typhonjs-fvtt/runtime/util/object';
import { ripple, rippleFocus } from '@typhonjs-fvtt/standard/action/animate/composable';
import { getFormat } from '@typhonjs-fvtt/runtime/data/color/colord';
import { propertyStore } from '@typhonjs-fvtt/runtime/svelte/store/writable-derived';
import { TJSStyleManager } from '@typhonjs-fvtt/runtime/util/dom/style';
import { validate } from '@typhonjs-fvtt/runtime/util/semver';

/**
 * Controls preparation and processing of registered game settings w/ TJSGameSettingsUI. Game settings are parsed
 * for UI display by TJSSettingsEdit. The store `showSettings` is utilized in TJSSettingsSwap component to provide
 * an easy way to flip between settings component or any main slotted component.
 */
class UIControlImpl {
    /**
     */
    #sections = [];
    /**
     */
    #settings;
    /**
     */
    #showSettings = false;
    /**
     */
    #showSettingsSet;
    /**
     */
    #stores;
    /**
     * @param settings -
     */
    constructor(settings) {
        this.#settings = settings;
        const showSettings = writable(this.#showSettings);
        this.#showSettingsSet = showSettings.set;
        this.#stores = {
            showSettings: { subscribe: showSettings.subscribe }
        };
        Object.freeze(this.#stores);
    }
    /**
     * @returns Current `showSettings` state.
     */
    get showSettings() {
        return this.#showSettings;
    }
    /**
     * @returns Returns the managed stores.
     */
    get stores() {
        return this.#stores;
    }
    /**
     * Sets current `showSettings` state.
     *
     * @param showSettings - New `showSettings` state.
     */
    set showSettings(showSettings) {
        if (typeof showSettings !== 'boolean') {
            throw new TypeError('showSettings must be a boolean');
        }
        this.#showSettings = showSettings;
        this.#showSettingsSet(this.#showSettings);
    }
    /**
     * Adds a custom section / folder defined by the provided TJSSettingsCustomSection options object.
     *
     * @param options - The configuration object for the custom section.
     */
    addSection(options) {
        if (!isObject(options)) {
            throw new TypeError(`'options' is not an object.`);
        }
        if (!TJSSvelte.util.isComponent(options.class)) {
            throw new TypeError(`'options.class' is not a Svelte component.`);
        }
        if (options.props !== void 0 && !isObject(options.props)) {
            throw new TypeError(`'options.props' is not an object.`);
        }
        if (options.folder !== void 0) {
            const folder = options.folder;
            if (typeof folder !== 'string' && !isObject(folder)) {
                throw new TypeError(`'options.folder' is not a string or object.`);
            }
            if (isObject(folder)) {
                if (typeof folder.label !== 'string') {
                    throw new TypeError(`'options.folder.label' is not a string.`);
                }
                // Validate custom component set as folder summary end.
                if (folder.summaryEnd !== void 0) {
                    if (!isObject(folder.summaryEnd)) {
                        throw new TypeError(`'options.folder.summaryEnd' is not an object.`);
                    }
                    if (!TJSSvelte.util.isComponent(folder.summaryEnd.class)) {
                        throw new TypeError(`'options.folder.summaryEnd.class' is not a Svelte component.`);
                    }
                    if (folder.summaryEnd.props !== void 0 && !isObject(folder.summaryEnd.props)) {
                        throw new TypeError(`'options.folder.summaryEnd.props' is not an object.`);
                    }
                }
                // Validate that folder inline styles is an object.
                if (folder.styles !== void 0 && !isObject(folder.styles)) {
                    throw new TypeError(`'options.folder.styles' is not an object.`);
                }
            }
        }
        // Validate that section inline styles is an object.
        if (options.styles !== void 0 && !isObject(options.styles)) {
            throw new TypeError(`'options.styles' is not an object.`);
        }
        this.#sections.push(options);
    }
    /**
     * Creates the `TJSSettingsUI.Data` object by parsing stored settings in the associated {@link TJSGameSettings}
     * instance.
     *
     * @param [options] - Create options
     *
     * @returns Parsed UI settings data.
     */
    create(options) {
        const settings = this.#parseSettings(options);
        const destroy = () => this.#destroy(settings);
        return {
            ...settings,
            destroy
        };
    }
    /**
     * Destroy callback. Checks for any `requiresReload` parameter in each setting comparing against initial value
     * when `settings` is created and current value. If there is a difference then show a modal dialog asking the user
     * if they want to reload for those settings to take effect.
     *
     * @param settings - The UI data object initiated w/ `create`.
     */
    #destroy(settings) {
        let requiresClientReload = false;
        let requiresWorldReload = false;
        if (Array.isArray(settings.topLevel)) {
            for (const setting of settings.topLevel) {
                const current = globalThis.game.settings.get(setting.namespace, setting.key);
                if (current === setting.initialValue) {
                    continue;
                }
                requiresClientReload ||= (setting.scope === 'client') && setting.requiresReload;
                requiresWorldReload ||= (setting.scope === 'world') && setting.requiresReload;
            }
        }
        if (Array.isArray(settings.folders)) {
            for (const folder of settings.folders) {
                if (Array.isArray(folder.settings)) {
                    for (const setting of folder.settings) {
                        const current = globalThis.game.settings.get(setting.namespace, setting.key);
                        if (current === setting.initialValue) {
                            continue;
                        }
                        requiresClientReload ||= (setting.scope === 'client') && setting.requiresReload;
                        requiresWorldReload ||= (setting.scope === 'world') && setting.requiresReload;
                    }
                }
            }
        }
        if (requiresClientReload || requiresWorldReload) {
            this.#reloadConfirm({ world: requiresWorldReload });
        }
        this.#showSettings = false;
        this.#showSettingsSet(this.#showSettings);
    }
    /**
     * @param [options] - Optional parameters.
     *
     * @returns Parsed UI settings data.
     */
    #parseSettings({ efx = 'ripple', storage } = {}) {
        const namespace = this.#settings.namespace;
        if (storage && typeof namespace !== 'string') {
            console.warn(`TJSGameSettings warning: 'options.storage' defined, but 'namespace' not defined in TJSGameSettings.`);
        }
        const hasStorage = storage !== void 0 && typeof namespace === 'string';
        const uiSettings = [];
        const canConfigure = globalThis.game.user.can('SETTINGS_MODIFY');
        for (const setting of this.#settings.data()) {
            if (!isObject(setting.options) || !setting.options.config ||
                (!canConfigure && (setting.options.scope !== 'client'))) {
                continue;
            }
            let options;
            if (isObject(setting.options.choices)) {
                options = Object.entries(setting.options.choices).map((entry) => ({ value: entry[0], label: localize(entry[1]) }));
            }
            let range;
            if (isObject(setting.options.range)) {
                // Verify range data.
                if (typeof setting.options.range.min !== 'number') {
                    throw new TypeError(`Setting 'options.range.min' is not a number.`);
                }
                if (typeof setting.options.range.max !== 'number') {
                    throw new TypeError(`Setting 'options.range.max' is not a number.`);
                }
                if (setting.options.range.step !== void 0 && typeof setting.options.range.step !== 'number') {
                    throw new TypeError(`Setting 'options.range.step' is not a number.`);
                }
                range = {
                    min: setting.options.range.min,
                    max: setting.options.range.max,
                    step: setting.options.range.step ?? 1
                };
            }
            // Default to `String` if no type is provided.
            const type = setting.options.type instanceof Function ? setting.options.type.name : 'String';
            // Only configure file picker if setting type is a string.
            let filePicker;
            if (type === 'String') {
                switch (typeof setting.options.filePicker) {
                    case 'boolean':
                        filePicker = setting.options.filePicker ? 'any' : void 0;
                        break;
                    case 'string':
                        filePicker = setting.options.filePicker;
                        break;
                }
            }
            let buttonData;
            if (filePicker) {
                buttonData = {
                    icon: 'fas fa-file-import fa-fw',
                    efx: efx === 'ripple' ? ripple() : void 0,
                    title: 'FILES.BrowseTooltip',
                    styles: { 'margin-left': '0.25em' }
                };
            }
            const store = this.#settings.getStore(setting.key);
            let selectData;
            let componentType = 'text';
            if (setting.options.type === Boolean) {
                componentType = 'checkbox';
            }
            else if (options !== void 0) {
                componentType = 'select';
                selectData = {
                    store,
                    efx: efx === 'ripple' ? rippleFocus() : void 0,
                    type: componentType,
                    options
                };
            }
            else if (setting.options.type === Number) {
                componentType = isObject(setting.options.range) ? 'range' : 'number';
            }
            let inputData;
            if (componentType === 'text' || componentType === 'number') {
                inputData = {
                    store,
                    efx: efx === 'ripple' ? rippleFocus() : void 0,
                    type: componentType
                };
            }
            uiSettings.push({
                id: `${setting.namespace}.${setting.key}`,
                namespace: setting.namespace,
                folder: setting.folder,
                key: setting.key,
                name: localize(setting.options?.name ?? ''),
                hint: localize(setting.options?.hint ?? ''),
                type,
                componentType,
                filePicker,
                range,
                store,
                initialValue: globalThis.game.settings.get(setting.namespace, setting.key),
                scope: setting.options.scope,
                requiresReload: typeof setting.options.requiresReload === 'boolean' ? setting.options.requiresReload :
                    false,
                buttonData,
                inputData,
                selectData
            });
        }
        // If storage is available then create a key otherwise create a dummy store, so `applyScrolltop` works.
        const storeScrollbar = hasStorage && storage ?
            storage.getStore(`${namespace}-settings-scrollbar`) : writable(0);
        const topLevel = [];
        const folderData = {};
        // Sort into folders
        for (const setting of uiSettings) {
            if (typeof setting.folder === 'string') {
                const folderName = localize(setting.folder);
                // Create folder array if one doesn't exist already.
                if (!Array.isArray(folderData[folderName])) {
                    folderData[folderName] = [];
                }
                folderData[folderName].push(setting);
            }
            else // Add to 'toplevel' settings
             {
                topLevel.push(setting);
            }
        }
        // Convert folderData object to array.
        const folders = Object.entries(folderData).map((entry) => {
            return {
                label: entry[0],
                store: hasStorage && storage ? storage.getStore(`${namespace}-settings-folder-${entry[0]}`) : void 0,
                settings: entry[1],
            };
        });
        const sections = [];
        // Parse custom component sections
        for (const section of this.#sections) {
            const parsedSection = {
                class: section.class,
                props: section.props,
                styles: section.styles
            };
            if (typeof section.folder === 'string') {
                const label = localize(section.folder);
                parsedSection.folder = {
                    label,
                    store: hasStorage && storage ? storage.getStore(`${namespace}-settings-folder-${label}`) : void 0
                };
            }
            else if (isObject(section.folder)) {
                const label = localize(section.folder.label);
                parsedSection.folder = {
                    label,
                    store: hasStorage && storage ? storage.getStore(`${namespace}-settings-folder-${label}`) : void 0,
                    summaryEnd: section.folder.summaryEnd,
                    styles: section.folder.styles
                };
            }
            sections.push(parsedSection);
        }
        return {
            storeScrollbar,
            topLevel,
            folders,
            sections
        };
    }
    async #reloadConfirm({ world = false } = {}) {
        let title = localize('SETTINGS.ReloadPromptTitle');
        let label = localize('SETTINGS.ReloadPromptBody');
        // Foundry v9 doesn't have the reload lang keys, so substitute just for English translation.
        // TODO: FOUNDRY_V9 - remove when support for v9 is dropped.
        title = title !== 'SETTINGS.ReloadPromptTitle' ? title : 'Reload Application?';
        label = label !== 'SETTINGS.ReloadPromptBody' ? label :
            'Some of the changed settings require a reload of the application to take effect. Would you like to reload now?';
        const reload = await TJSDialog.confirm({
            modal: true,
            draggable: false,
            title,
            content: `<p>${label}</p>`
        });
        if (!reload) {
            return;
        }
        // Reload all connected clients. Note: Foundry v9 might not support this event.
        if (world && globalThis.game.user.isGM) {
            globalThis.game.socket.emit('reload');
        }
        // Reload locally.
        window.location.reload();
    }
    /**
     * Convenience method to swap `showSettings`.
     *
     * @returns {boolean} New `showSettings` state.
     */
    swapShowSettings() {
        this.#showSettings = !this.#showSettings;
        this.#showSettingsSet(this.#showSettings);
        return this.#showSettings;
    }
}

/**
 * Extends {@link TJSGameSettings} with UI control for working with
 * {@link #standard/component/fvtt/settings!TJSSettingsEdit} and
 * {@link #standard/component/fvtt/settings!TJSSettingsSwap}
 * components. Instead of extending `TJSGameSettings` simply extend `TJSGameSettingsWithUI` instead when creating
 * reactive game settings that utilize the above components.
 *
 * There are additional game settings options for separating settings into folders. Please see
 * {@link TJSGameSettingsWithUI.Options.ExtraProps}.
 */
class TJSGameSettingsWithUI extends TJSGameSettings {
    /**
     */
    #uiControl;
    /**
     * Creates the TJSGameSettingsWithUI instance.
     *
     * @param namespace - The namespace for all settings.
     */
    constructor(namespace) {
        super(namespace);
        this.#uiControl = new UIControlImpl(this);
    }
    register(setting) {
        if (setting?.folder !== void 0 && typeof setting.folder !== 'string') {
            throw new TypeError(`TJSGameSettingsWithUI - register: 'folder' attribute is not a string.`);
        }
        super.register(setting);
    }
    /**
     * @returns The associated UIControl.
     */
    get uiControl() {
        return this.#uiControl;
    }
}

class DataValidator {
    constructor() { }
    /**
     * This regex tests for correct CSS variable names according to the CSS specification.
     *
     * @see https://www.w3.org/TR/css-variables-1/#defining-variables
     * @see https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
     */
    static #REGEX_CSS_VAR_NAME = /--(?:[_a-zA-Z\u00A0-\uFFFF]|\\[0-9a-fA-F]{1,6})(?:[\w\u00A0-\uFFFF-]|\\[0-9a-fA-F]{1,6})*/;
    static #SET_TYPES = new Set(['color']);
    /**
     * Parses and verifies a component entry.
     *
     * @param entry - A component entry.
     *
     * @param {number}   cntr - Current component entry counter.
     *
     * @returns {object} Parsed and verified component entry.
     */
    static componentEntry(entry, cntr) {
        const result = Object.assign({}, entry);
        if (!isObject(entry)) {
            throw new TypeError(`TJSThemeStore initialize error: data[${cntr}] entry is not an object.`);
        }
        if (typeof entry.label !== 'string') {
            throw new Error(`TJSThemeStore initialize error: data[${cntr}] 'entry.label' is not a string.`);
        }
        if (typeof entry.type !== 'string') {
            throw new Error(`TJSThemeStore initialize error: data[${cntr}] 'entry.type' is not a string.`);
        }
        if (!this.#SET_TYPES.has(entry.type)) {
            throw new Error(`TJSThemeStore initialize error: data[${cntr}] 'entry.type' unknown.`);
        }
        if (entry.var !== void 0 && typeof entry.var !== 'string') {
            throw new TypeError(`TJSThemeStore initialize error: data[${cntr}] 'entry.var' is not a string.`);
        }
        // Handle common data for CSS variable entries.
        if (typeof entry.var === 'string') {
            // Test for valid CSS variable name
            if (!this.#REGEX_CSS_VAR_NAME.test(entry.var)) {
                throw new Error(`TJSThemeStore initialize error: data[${cntr}] 'entry.var' is not a valid CSS variable name.`);
            }
            if (typeof entry.default !== 'string') {
                throw new TypeError(`TJSThemeStore initialize error: data[${cntr}] 'entry.default' is not a string.`);
            }
        }
        switch (entry.type) {
            case 'color':
                {
                    // Verify that default value is a supported color format.
                    const format = entry.default ? getFormat(entry.default) : void 0;
                    if (!format) {
                        throw new Error(`TJSThemeStore initialize error: data[${cntr}] 'entry.default' unknown color format.`);
                    }
                    // Add the color format to entry result data.
                    result.format = format;
                    break;
                }
        }
        return result;
    }
}

/**
 * Must be constructed from a TJSGameSettings instance `init` / initialize method called from the `ready` Foundry VTT
 * hook.
 */
class TJSThemeStore {
    /**
     */
    #components = [];
    /**
     */
    #data = {};
    #defaultThemeData = {};
    #initialThemeData = {};
    #storeComponents = { subscribe: writable(this.#components).subscribe };
    /**
     * All property stores.
     */
    #storeProps = {};
    /**
     */
    #styleManager;
    /**
     * Stores the subscribers.
     */
    #subscribers = [];
    /**
     * Stores all CSS variable keys.
     */
    #vars = [];
    /**
     * Current theme version.
     */
    #version;
    /**
     * @param options - Options
     */
    constructor(options) {
        if (!isObject(options)) {
            throw new TypeError(`'options' is not an object.`);
        }
        if (typeof options.namespace !== 'string') {
            throw new TypeError(`'namespace' attribute is not a string.`);
        }
        if (typeof options.key !== 'string') {
            throw new TypeError(`'key' attribute is not a string.`);
        }
        if (!(options.gameSettings instanceof TJSGameSettings)) {
            throw new TypeError(`'gameSettings' attribute is not an instance of TJSGameSettings.`);
        }
        if (!(options.styleManager instanceof TJSStyleManager)) {
            throw new TypeError(`'styleManager' attribute is not an instance of TJSStyleManager.`);
        }
        if (!isObject(options.config)) {
            throw new TypeError(`'config' attribute is not an object. `);
        }
        if (typeof options.config.version !== 'string') {
            throw new TypeError(`'config.version' attribute is not a string`);
        }
        if (!validate(options.config.version)) {
            throw new Error(`'config.version' attribute is not a valid semantic version string.`);
        }
        this.#version = options.config.version;
        if (!isIterable(options.config.components)) {
            throw new TypeError(`'config.components' attribute is not an iterable list. `);
        }
        this.#styleManager = options.styleManager;
        this.#initialize(options);
    }
    /**
     * @returns A readable store of all components.
     */
    get components() { return this.#storeComponents; }
    /**
     * @returns All property stores.
     */
    get properties() {
        return this.#storeProps;
    }
    /**
     * Parse `options.config` and initialize game setting for theme data.
     *
     * @param options -
     */
    #initialize(options) {
        this.#defaultThemeData = {};
        this.#initialThemeData = Object.assign({}, this.#defaultThemeData);
        let cntr = 0;
        // Process component / vars data.
        for (let entry of options.config.components) {
            // Validate entry, but also adds additional information based on data types; IE `format` for `color`.
            entry = DataValidator.componentEntry(entry, cntr);
            // Add var key if defined.
            if (typeof entry.var === 'string') {
                const key = entry.var;
                this.#vars.push(key);
                this.#storeProps[key] = propertyStore(this, key);
                this.#components.push(Object.assign({}, entry, { store: this.#storeProps[key] }));
                if (typeof entry.default === 'string') {
                    this.#defaultThemeData[key] = entry.default;
                }
            }
            else {
                this.#components.push(Object.assign({}, entry));
            }
            cntr++;
        }
        // Set initial data to default here just in case the game setting entry is invalid upon registration / IE null.
        this.#initialThemeData = Object.assign({}, this.#defaultThemeData);
        options.gameSettings.register({
            namespace: options.namespace,
            key: options.key,
            store: this,
            options: {
                scope: 'world',
                config: false,
                default: Object.assign({}, this.#defaultThemeData),
                type: Object
            }
        });
        // Retrieve existing data from stored word setting.
        this.#initialThemeData = game.settings.get(options.namespace, options.key);
        // Validate initial theme data and set to default if it fails to validate.
        if (!this.#validateThemeData(this.#initialThemeData, false)) {
            console.warn(`TJSThemeStore warning: Initial theme data invalid. Setting to default data.`);
            this.#initialThemeData = Object.assign({}, this.#defaultThemeData);
            this.set(Object.assign({}, this.#initialThemeData));
        }
    }
    /**
     * Sets the theme store with new data.
     *
     * @param themeData -
     *
     * @returns This theme store instance.
     */
    set(themeData) {
        if (!this.#validateThemeData(themeData)) {
            themeData = Object.assign({}, this.#initialThemeData);
        }
        for (const key of this.#vars) {
            if (key in themeData) {
                const keyData = themeData[key];
                this.#data[key] = keyData;
                this.#styleManager.setProperty(key, keyData);
            }
        }
        this.#updateSubscribers();
        return this;
    }
    /**
     * Validates the given theme data object ensuring that all parameters are found and are correct HSVA values.
     *
     * @param themeData -
     *
     * @param [warn] - When true post warning message.
     *
     * @returns Validation status.
     */
    #validateThemeData(themeData, warn = true) {
        if (!isObject(themeData)) {
            if (warn) {
                console.warn(`TJSThemeStore warning: 'theme' data is not an object resetting to initial data.`);
            }
            return false;
        }
        for (const key of this.#vars) {
            const data = themeData[key];
            if (getFormat(data) !== 'hsl') {
                if (warn) {
                    console.warn(`TJSThemeStore warning: data for property '${key}' is not a HSL color string. Resetting to initial data.`);
                }
                return false;
            }
        }
        return true;
    }
    // ------------
    /**
     * Updates all subscribers
     */
    #updateSubscribers() {
        const data = Object.assign({}, this.#data);
        // Early out if there are no subscribers.
        if (this.#subscribers.length > 0) {
            for (let cntr = 0; cntr < this.#subscribers.length; cntr++) {
                this.#subscribers[cntr](data);
            }
        }
    }
    /**
     * @param handler - Callback function that is invoked on update / changes. Receives copy of the theme data.
     *
     * @returns Unsubscribe function.
     */
    subscribe(handler) {
        this.#subscribers.push(handler); // add handler to the array of subscribers
        handler(Object.assign({}, this.#data)); // call handler with current value
        // Return unsubscribe function.
        return () => {
            const index = this.#subscribers.findIndex((sub) => sub === handler);
            if (index >= 0) {
                this.#subscribers.splice(index, 1);
            }
        };
    }
}

export { TJSGameSettingsWithUI, TJSThemeStore };
//# sourceMappingURL=index.js.map
